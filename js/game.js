// Generated by CoffeeScript 1.3.1
(function() {
  var ws,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Array.prototype.remove = function(item) {
    var indx;
    indx = this.indexOf(item);
    if (indx !== -1) {
      return this.splice(indx, 1);
    }
  };

  ws = new WebSocket('ws://' + window.location.hostname + ':8079');

  ws.onmessage = function(message) {
    var avatar, bubble, data, n, player, _i, _len, _ref, _results;
    data = JSON.parse(message.data);
    if (!data.debrief) {
      console.log(data);
    }
    if (data.disconnect != null) {
      if ($('#' + data.disconnect)[0] != null) {
        return $('#' + data.disconnect).detach();
      }
    } else if (data.connect != null) {
      player = data.connect;
      if (!($('#' + player.ID)[0] != null)) {
        avatar = $('<div class="player", id="' + player.ID + '"></div>');
        avatar.css({
          width: player.w,
          height: player.h,
          'background-color': 'gray',
          position: 'absolute',
          left: player.x,
          top: player.y
        });
        return $('#viewport').append(avatar);
      }
    } else if (data.chat != null) {
      if ($('#' + data.who)[0] != null) {
        bubble = $('<p class="bubble" >' + data.chat + '</p>');
        $('#' + data.who).html(bubble);
        bubble.css('margin-top', -1 * bubble.height() - 15);
        return bubble.delay(2000).animate({
          opacity: 0.0
        }, 300, function() {
          return bubble.deatch();
        });
      }
    } else if (data.load != null) {
      console.log('load');
      n = data.load;
      return $.get('./levels/level' + n + '.html', function(data) {
        return $('#viewport').html(data);
      });
    } else if (data.debrief != null) {
      _ref = data.debrief;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (!($('#' + player.ID)[0] != null)) {
          avatar = $('<div class="player", id="' + player.ID + '"></div>');
          avatar.css({
            width: player.w,
            height: player.h,
            'background-color': 'gray',
            position: 'absolute',
            left: player.x,
            top: player.y
          });
          _results.push($('#viewport').append(avatar));
        } else {
          avatar = $('#' + player.ID);
          _results.push(avatar.css({
            left: player.x,
            top: player.y
          }));
        }
      }
      return _results;
    }
  };

  window.keys = [];

  $(window).keydown(function(e) {
    var _ref;
    if ($('#chat').is(':focus')) {
      if (e.keyCode === 13) {
        ws.send(JSON.stringify({
          'chat': $('#chat').val()
        }));
        return $('#chat').val('');
      }
    } else if (_ref = e.keyCode, __indexOf.call(window.keys, _ref) < 0) {
      window.keys.push(e.keyCode);
      return ws.send(JSON.stringify({
        'keydown': e.keyCode
      }));
    }
  });

  $(window).keyup(function(e) {
    window.keys.remove(e.keyCode);
    return ws.send(JSON.stringify({
      'keyup': e.keyCode
    }));
  });

  window.compile_level = function(url) {
    return $.get('./levels/' + url, function(data) {
      var child, recurse, result, temp, _i, _len, _ref;
      result = [];
      temp = $('<div></div>');
      temp.append($(data));
      recurse = function(el) {
        var b, child, _i, _len, _ref, _results;
        if (!$(el).hasClass('no_collision')) {
          b = {
            x: parseInt($(el).css('left')),
            y: parseInt($(el).css('top')),
            w: parseInt($(el).outerWidth()),
            h: parseInt($(el).outerHeight())
          };
          result.push(b);
          _ref = $(el).children();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            _results.push(recurse(child));
          }
          return _results;
        }
      };
      _ref = $(temp).children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        recurse(child);
      }
      return console.log(JSON.stringify(result));
    });
  };

}).call(this);
